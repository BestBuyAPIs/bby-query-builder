How to Add More Tabs to the Query Builder

1. Create a directory for the tab inside `app/` where the js, css and html files will live
1. Instantiate a new module for the tab and add it as a dependency to the main angular app module in `app/app.js`. Your controller and tab-specific services/constants/directives should be added to that specific module. If you need to use that code in other tabs, you can add those to the app-wide `appConstants` or `appServices` instead.
1. Add the file path for the above directory to the jsFiles and the cssFiles array in `Gruntfile.js` and the test coverage in `karma.conf.js` . This ensures that the js and css files will be added to the `app/production.js` and `app/production.css` files that will actually get run by the page.
1. The pattern QB has followed is for each tab to have its own `00-module.js` file where the module is instantiated and the controller is tied to the view, so that the ng-router can do its thing.
1. Add test files for the tab to the `app/test` directory. the name should be *tabName*_test.js to be consistent
1. The `appConstants` and `appServices` files hold functions and other data that are used in multiple tabs. If your tab needs these, simply add them as dependencies into your tab's controller.
1. Each tab has some calls to Google Analytics that register events such as a successful call to the remix api or using the clipboard button to copy a query url. the main Google Analytics functions are in a service in `app/appServices/analytics.js` You can also look at the other invoke___query functions in the other tabs to get an idea on how to configure that.
1. To check the test coverage of your new file when it is all configured, open the `index.html` at `./coverage/../index.html`. This file is created after running `npm test`.
1. Presently, our own js and css files are concatened so we only need to call on one file each. Each small js and css file took up a network request and by cutting those requests in half with concatenation, we got the QB to load in roughly half the time. However, the bower components are not concatened (though this is possible with grunt) so new ones will have to be included in the `/app/index.html` file
1. The multi-select boxes use the ui-select directive from the angular ui team. The dynamic forms (the +/- ones on the products tab for example) are mostly custom written. There is a form template tied to the scope, and an ng-repeat renders a list of items where the items are instances of that form template. The dynamic forms are set to a ng-model such as `showOptions.list` where `showOptions` is set as an empty object. the `.list` is important.  Then the parseDynamicForms service is called to pull all of those form items together and return an array of values. The parseDynamicForms functions also have special rules for the outlier values like 'sku in' that require special syntax in the api.
1. Whenever possible, constants such as a list of values to populate a select dropdown are put into angular `.constants` instead of keeping them in controllers. $scope values that will end up changing are harder to put into angular constants, so each controllers resetParams function will have those.